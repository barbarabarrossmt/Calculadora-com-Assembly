section .data
    ; Mensagens do programa
    msg_menu      db 10, '=== CALCULADORA ASSEMBLY ===', 10
                  db '1. Soma', 10
                  db '2. Subtracao', 10
                  db '3. Multiplicacao', 10
                  db '4. Divisao', 10
                  db '5. Sair', 10
                  db 'Escolha uma opcao: ', 0
    len_menu      equ $ - msg_menu
    
    msg_num1      db 10, 'Digite o primeiro numero: ', 0
    len_num1      equ $ - msg_num1
    
    msg_num2      db 'Digite o segundo numero: ', 0
    len_num2      equ $ - msg_num2
    
    msg_result    db 10, 'Resultado: ', 0
    len_result    equ $ - msg_result
    
    msg_erro      db 10, 'Opcao invalida!', 10, 0
    len_erro      equ $ - msg_erro
    
    msg_div_zero  db 10, 'Erro: Divisao por zero!', 10, 0
    len_div_zero  equ $ - msg_div_zero
    
    newline       db 10, 0
    len_newline   equ $ - newline

section .bss
    opcao     resb 2
    num1      resb 10
    num2      resb 10
    resultado resb 10
    buffer    resb 10

section .text
    global _start

_start:
    ; Loop principal do programa
    main_loop:
        ; Exibir menu
        call exibir_menu
        
        ; Ler opção do usuário
        mov eax, 3          ; sys_read
        mov ebx, 0          ; stdin
        mov ecx, opcao      ; buffer
        mov edx, 2          ; tamanho
        int 0x80
        
        ; Verificar se quer sair
        cmp byte [opcao], '5'
        je sair
        
        ; Validar opção
        cmp byte [opcao], '1'
        jb opcao_invalida
        cmp byte [opcao], '4'
        ja opcao_invalida
        
        ; Ler números
        call ler_numeros
        
        ; Executar operação baseada na opção
        cmp byte [opcao], '1'
        je somar
        cmp byte [opcao], '2'
        je subtrair
        cmp byte [opcao], '3'
        je multiplicar
        cmp byte [opcao], '4'
        je dividir
        
    jmp main_loop

; Sub-rotina para exibir menu
exibir_menu:
    mov eax, 4          ; sys_write
    mov ebx, 1          ; stdout
    mov ecx, msg_menu
    mov edx, len_menu
    int 0x80
    ret

; Sub-rotina para ler números
ler_numeros:
    ; Pedir primeiro número
    mov eax, 4
    mov ebx, 1
    mov ecx, msg_num1
    mov edx, len_num1
    int 0x80
    
    ; Ler primeiro número
    mov eax, 3
    mov ebx, 0
    mov ecx, num1
    mov edx, 10
    int 0x80
    
    ; Pedir segundo número
    mov eax, 4
    mov ebx, 1
    mov ecx, msg_num2
    mov edx, len_num2
    int 0x80
    
    ; Ler segundo número
    mov eax, 3
    mov ebx, 0
    mov ecx, num2
    mov edx, 10
    int 0x80
    
    ; Converter strings para inteiros
    mov esi, num1
    call string_para_int
    mov ebx, eax        ; guardar num1 em ebx
    
    mov esi, num2
    call string_para_int
    mov ecx, eax        ; guardar num2 em ecx
    
    ret

; Operação de soma
somar:
    add ebx, ecx        ; ebx = ebx + ecx
    mov eax, ebx
    call exibir_resultado
    jmp main_loop

; Operação de subtração
subtrair:
    sub ebx, ecx        ; ebx = ebx - ecx
    mov eax, ebx
    call exibir_resultado
    jmp main_loop

; Operação de multiplicação
multiplicar:
    mov eax, ebx
    imul eax, ecx       ; eax = ebx * ecx
    call exibir_resultado
    jmp main_loop

; Operação de divisão
dividir:
    ; Verificar divisão por zero
    cmp ecx, 0
    je erro_div_zero
    
    mov eax, ebx
    cdq                 ; estender sinal para edx
    idiv ecx            ; eax = ebx / ecx
    call exibir_resultado
    jmp main_loop

; Sub-rotina para exibir resultado
exibir_resultado:
    push eax
    ; Exibir mensagem de resultado
    mov eax, 4
    mov ebx, 1
    mov ecx, msg_result
    mov edx, len_result
    int 0x80
    pop eax
    
    ; Converter inteiro para string e exibir
    call int_para_string
    mov edx, eax        ; edx = tamanho da string
    mov eax, 4          ; sys_write
    mov ebx, 1          ; stdout
    mov ecx, buffer     ; buffer com o número
    int 0x80
    
    ; Nova linha
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, len_newline
    int 0x80
    
    ret

; Converter string para inteiro
; Entrada: ESI = ponteiro para string
; Saída: EAX = inteiro
string_para_int:
    xor eax, eax        ; zerar eax
    xor ebx, ebx        ; zerar ebx
    
    .loop:
        mov bl, [esi]   ; pegar caractere
        cmp bl, 10      ; verificar newline
        je .fim
        cmp bl, 0       ; verificar null
        je .fim
        
        sub bl, '0'     ; converter ASCII para número
        imul eax, 10    ; eax *= 10
        add eax, ebx    ; eax += dígito
        
        inc esi         ; próximo caractere
        jmp .loop
    
    .fim:
    ret

; Converter inteiro para string
; Entrada: EAX = inteiro
; Saída: EAX = tamanho da string, buffer preenchido
int_para_string:
    mov edi, buffer + 9 ; apontar para final do buffer
    mov byte [edi], 0   ; null terminator
    mov ebx, 10         ; divisor
    
    ; Verificar se é negativo
    test eax, eax
    jns .positivo
    neg eax             ; tornar positivo
    mov byte [buffer], '-' ; sinal negativo
    jmp .loop
    
    .positivo:
    mov byte [buffer], '+' ; sinal positivo
    
    .loop:
        dec edi
        xor edx, edx    ; zerar edx
        div ebx         ; eax = quociente, edx = resto
        add dl, '0'     ; converter para ASCII
        mov [edi], dl   ; armazenar caractere
        
        test eax, eax   ; verificar se terminou
        jnz .loop
    
    ; Calcular tamanho
    mov eax, buffer + 10
    sub eax, edi        ; eax = tamanho
    
    ; Mover string para início do buffer se necessário
    push eax
    mov esi, edi
    mov edi, buffer + 1 ; pular o sinal
    mov ecx, eax
    rep movsb
    pop eax
    
    inc eax             ; incluir o sinal no tamanho
    ret

; Tratamento de erros
opcao_invalida:
    mov eax, 4
    mov ebx, 1
    mov ecx, msg_erro
    mov edx, len_erro
    int 0x80
    jmp main_loop

erro_div_zero:
    mov eax, 4
    mov ebx, 1
    mov ecx, msg_div_zero
    mov edx, len_div_zero
    int 0x80
    jmp main_loop

; Sair do programa
sair:
    mov eax, 1          ; sys_exit
    mov ebx, 0          ; status 0
    int 0x80
